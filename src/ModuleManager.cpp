/*
 * This file is part of the Flowee project
 * Copyright (C) 2023 Tom Zander <tom@flowee.org>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#include "ModuleManager.h"

#include <QFile>
#include <QCoreApplication>
#include <QLocale>
#include <QStandardPaths>
#include <QTranslator>
#include <QGuiApplication>

#include <ripemd160.h>
#include <Logger.h>
#include <streaming/BufferPool.h>
#include <streaming/MessageBuilder.h>
#include <streaming/MessageParser.h>

#include <stdexcept>
#include <fstream>
#include <boost/filesystem.hpp>

enum ModuleConfigSaveTags {
    ModuleId = 1,
    ModuleSectionId,
    ModuleSectionEnabled
};


ModuleManager::ModuleManager(QObject *parent)
    : QObject(parent)
{
    m_configFile = QStandardPaths::locate(QStandardPaths::AppConfigLocation, "modules.conf");
    if (m_configFile.isEmpty()) {
        // make sure the directory exists
        auto path = QStandardPaths::writableLocation(QStandardPaths::AppConfigLocation);
        boost::filesystem::create_directories(boost::filesystem::path(path.toStdString()));
        m_configFile = path + '/' + "modules.conf";
    }

#ifdef TARGET_OS_Android
    auto guiApp = qobject_cast<QGuiApplication*>(QCoreApplication::instance());
    assert(guiApp);
    connect(guiApp, &QGuiApplication::applicationStateChanged, this, [=](Qt::ApplicationState state) {
        if (state == Qt::ApplicationInactive || state == Qt::ApplicationSuspended)
            save();
    });
#endif

    extern void load_all_modules(ModuleManager*);
    // the load_all_modules method is generated by cmake in the modules builddir.
    // it essentially makes each module call 'load' on this class.
    load_all_modules(this);
    load(); // restore user settings.

    // connect to signals of the sections so we tell the QML to get the new
    // filtered list on the user enabling / disabling something.
    for (const auto *m : m_modules) {
        for (auto *s : m->sections()) {
            connect (s, &ModuleSection::enabledChanged, this, [=]() {
                switch (s->type()) {
                case ModuleSection::SendMethod:
                    emit sendMenuSectionsChanged();
                default:
                    break;
                }
            });
        }
    }
}

ModuleManager::~ModuleManager()
{
    save();
}

void ModuleManager::load(const char *translationUnit, const std::function<ModuleInfo *()> &function)
{
    if (translationUnit) {
        QString translations = QString::fromUtf8(translationUnit);
        auto *translator = new QTranslator(this);
        /*
         * We try to load it from the default location as used in the translations subdir (:/i18n)
         * and if that fails we try again at the root level of the QRC because individual modules
         * can then just use one data.qrc and include translations, if they manage their own.
         */
        if (translator->load(QLocale(), translations, QLatin1String("_"), QLatin1String(":/i18n")))
            QCoreApplication::installTranslator(translator);
        else if (translator->load(QLocale(), translations, QLatin1String("_"), QLatin1String(":")))
            QCoreApplication::installTranslator(translator);
        else
            delete translator;
    }
    auto *info = function();
    if (info == nullptr)
        return;
    info->setParent(this); // take ownership
    m_modules.append(info);
}

void ModuleManager::load()
{
    // enforce default off, unless the user explicitly asks.
    for (const auto *m : m_modules) {
        for (auto *s : m->sections()) {
            s->setEnabled(false);
        }
    }

    std::ifstream in(m_configFile.toStdString());
    if (!in.is_open())
        return;

    auto dataSize = boost::filesystem::file_size(m_configFile.toStdString());
    Streaming::BufferPool pool(dataSize);
    in.read(pool.data(), dataSize);
    Streaming::MessageParser parser(pool.commit(dataSize));
    const ModuleInfo *info = nullptr;
    int type = -1;
    while (parser.next() == Streaming::FoundTag) {
        if (parser.tag() == ModuleId) {
            info = nullptr;
            type = -1;
            for (const auto *module : m_modules) {
                const QString wantedId = QString::fromUtf8(parser.stringData());
                if (module->id() == wantedId) {
                    info = module;
                    break;
                }
            }
        }
        else if (parser.tag() == ModuleSectionId) {
            type = parser.intData();
        }
        else if (parser.tag() == ModuleSectionEnabled) {
            for (auto *s : info->sections()) {
                if (s->type() == type) {
                    s->setEnabled(parser.boolData());
                    break;
                }
            }
        }
    }
}

void ModuleManager::save() const
{
    int saveFileSize = 100;
    for (const auto *m : m_modules) {
        saveFileSize += m->id().size() * 3;
        saveFileSize += m->sections().size() * 5;
    }

    Streaming::BufferPool pool(saveFileSize);
    Streaming::MessageBuilder builder(pool);
    for (const auto *m : m_modules) {
        builder.add(ModuleId, m->id().toStdString());
        for (const auto *s : m->sections()) {
            builder.add(ModuleSectionId, s->type());
            if (s->enabled())
                builder.add(ModuleSectionEnabled, s->enabled());
        }
    }

    auto data = builder.buffer();

    // hash the new file and check if its different lest we can skip saving
    QFile origFile(m_configFile);
    if (origFile.open(QIODevice::ReadOnly)) {
        CRIPEMD160 fileHasher;
        auto origContent = origFile.readAll();
        fileHasher.write(origContent.data(), origContent.size());
        char fileHash[CRIPEMD160::OUTPUT_SIZE];
        fileHasher.finalize(fileHash);

        CRIPEMD160 memHasher;
        memHasher.write(data.begin(), data.size());
        char memHash[CRIPEMD160::OUTPUT_SIZE];
        memHasher.finalize(memHash);
        if (memcmp(fileHash, memHash, CRIPEMD160::OUTPUT_SIZE) == 0) {
            // no changes, so don't write.
            return;
        }
    }
    try {
        auto configFile = m_configFile.toStdString();
        auto configFileNew = configFile + "~";
        boost::filesystem::remove(configFileNew);
        std::ofstream outFile(configFileNew);
        outFile.write(data.begin(), data.size());
        outFile.flush();
        outFile.close();
        boost::filesystem::rename(configFileNew, configFile);
    } catch (const std::exception &e) {
        logFatal() << "Failed to save the wallet.dat. Reason:" << e;
    }
}

QList<ModuleInfo *> ModuleManager::registeredModules() const
{
    return m_modules;
}

QList<ModuleSection *> ModuleManager::sendMenuSections() const
{
    QList<ModuleSection *> answer;
    for (const auto *m : m_modules) {
        for (auto *s : m->sections()) {
            if (s->enabled() && s->type() == ModuleSection::SendMethod)
                answer.append(s);
        }
    }
    return answer;
}
